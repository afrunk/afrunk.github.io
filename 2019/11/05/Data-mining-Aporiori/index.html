<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Data mining-Aporiori"><link rel="alternate" href="/default" title="天道宫"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="http://afrunk.github.io/2019/11/05/Data-mining-Aporiori/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css"><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":true};
</script>

    <title>Data mining-Aporiori - 天道宫</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">天道宫</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archivew
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">天道宫</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archivew
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Data mining-Aporiori
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-11-05
        </span><span class="post-category">
            <a href="/categories/机器学习算法系列/">机器学习算法系列</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、引文"><span class="toc-text">一、引文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-事务数据集及一些基本概念"><span class="toc-text">1.0 事务数据集及一些基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-支持度-support"><span class="toc-text">1.1 支持度 support</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-可信度（置信度）-confidence"><span class="toc-text">1.2 可信度（置信度） confidence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-提升度"><span class="toc-text">1.3 提升度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-强关联规则"><span class="toc-text">1.4 强关联规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-原理"><span class="toc-text">1.5 原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、频繁项集"><span class="toc-text">二、频繁项集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、关联规则"><span class="toc-text">三、关联规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、算法流程"><span class="toc-text">四、算法流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、优缺点"><span class="toc-text">五、优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-优点"><span class="toc-text">5.1 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-缺点"><span class="toc-text">5.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、算法推导实现流程"><span class="toc-text">六、算法推导实现流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、Director-Collaborator-Analysis"><span class="toc-text">七、Director Collaborator Analysis</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>无监督学习算法 Apriori 数据挖掘</p>
<a id="more"></a>

<h1 id="一、引文"><a href="#一、引文" class="headerlink" title="一、引文"></a>一、引文</h1><p>主要参考文献：</p>
<ul>
<li>《机器学习实战》：第十章 无监督学习</li>
<li><a href="https://blog.csdn.net/weixin_43378396/article/details/89576648" target="_blank" rel="noopener">Apriori</a></li>
<li>《数据挖掘：概念与技术第三版》</li>
</ul>
<p>在无监督学习中，类似分类和回归中的目标变量事先并不存在。与前面“对于输入数据X能预测变量Y”不同的是，这里要回答的问题是：“从数据X中能发现什么？”在一堆数据集中寻找数据之间的某种关联，这里主要介绍的是叫做Apriori的一个‘先验算法’，通过改算法我们可以对数据集做关联分析——在大规模的数据中寻找有趣关系的任务，本文主要介绍使用 Apriori算法发现数据集的频繁项集、关联规则,以及对于Apriori算法的一些调参方法。</p>
<p>这些关系可以有两种形式：<strong>频繁项集、关联规则</strong></p>
<ul>
<li>频繁项集：经常出现在一块的物品的集合</li>
<li>关联规则：暗示两种物品之间可能存在很强的关系</li>
</ul>
<p><img src="1.png" alt="具体例子"><br>频繁项集是指那些经常出现在一起的物品，例如上图的（葡萄酒、尿布、豆奶），从上面的数据集中也可以找到尿布-&gt;葡萄酒的关联规则，这意味着有人买了尿布，那很可能也会购买葡萄酒，那如何定义和表示频繁项集和关联规则呢？这里引入支持度和可信度（置信度）。</p>
<h2 id="1-0-事务数据集及一些基本概念"><a href="#1-0-事务数据集及一些基本概念" class="headerlink" title="1.0 事务数据集及一些基本概念"></a>1.0 事务数据集及一些基本概念</h2><ul>
<li>事务：每一条交易称为一个事务</li>
<li>事务数据集：设 $I={i_1,i_2,…,i_m}$是一个全局项的集合,事务数据库$D={t_1,t_2,…,t_n}$是一个事务的集合,每个事务$t_i(1\leq i \leq n)$都对应 I 上的一个子集,例如 $t_1 = {i_1,i_3,i_7}$.</li>
<li>项：交易的每一个物品称为一个项，例如豆奶、尿布等</li>
<li>项集：包含零个或多个</li>
</ul>
<h2 id="1-1-支持度-support"><a href="#1-1-支持度-support" class="headerlink" title="1.1 支持度 support"></a>1.1 支持度 support</h2><p><strong>一个项集得支持度被定义为数据集中包含该项集得记录所占的比例</strong>，上图中，豆奶的支持度为4/5，（豆奶、尿布）为3/5，支持度是针对项集来说的，因此可以定义一个最小支持度，只保留最小支持度的项集。</p>
<h2 id="1-2-可信度（置信度）-confidence"><a href="#1-2-可信度（置信度）-confidence" class="headerlink" title="1.2 可信度（置信度） confidence"></a>1.2 可信度（置信度） confidence</h2><p><strong>置信度表示Y 数据出现后,X数据出现的可能性,也可以说是数据的条件概率</strong>.<br>针对如{尿布}-&gt;{葡萄酒}这样的关联规则来定义的。计算为 支持度{尿布，葡萄酒}/支持度{尿布}，其中{尿布，葡萄酒}的支持度为3/5，{尿布}的支持度为4/5，所以“尿布-&gt;葡萄酒”的可行度为3/4=0.75，这意味着尿布的记录中，我们的规则有75%都适用。</p>
<p>有了可以量化的计算方式，我们却还不能立刻运算，这是因为如果我们直接运算所有的数据，运算量极其的大，很难实现，这里说明一下，假设我们只有4种商品：商品0，商品1，商品2，商品3，那么如何得到可能被一起购买的商品的组合？</p>
<p><img src="2.png" alt="计算方法"><br>上图显示了物品之间所有可能的组合，从上往下一个集合是 Ø，表示不包含任何物品的空集，物品集合之间的连线表明两个或者更多集合可以组合形成一个更大的集合。我们的目标是找到经常在一起购买的物品集合。这里使用集合的支持度来度量其出现的频率。一个集合出现的支持度是指有多少比例的交易记录包含该集合。例如，对于上图，要计算 0,3 的支持度，直接的想法是遍历每条记录，统计包含有 0 和 3 的记录的数量，使用该数量除以总记录数，就可以得到支持度。而这只是针对单个集合 0,3. 要获得每种可能集合的支持度就需要多次重复上述过程。对于上图，虽然仅有4中物品，也需要遍历数据15次。随着物品数目的增加，遍历次数会急剧增加，对于包含 N 种物品的数据集共有 2^N−1 种项集组合。为了降低计算时间，研究人员发现了 Apriori 原理，可以帮我们减少感兴趣的频繁项集的数目。</p>
<h2 id="1-3-提升度"><a href="#1-3-提升度" class="headerlink" title="1.3 提升度"></a>1.3 提升度</h2><p>提升度体现 X和 Y之间的关联关系,提升度大于1表示X和Y之间具有强关联关系,提升度小于等于1表示X和Y之间无有效的强关联关系.</p>
<h2 id="1-4-强关联规则"><a href="#1-4-强关联规则" class="headerlink" title="1.4 强关联规则"></a>1.4 强关联规则</h2><p>满足最小支持度和最小置信度的关联规则</p>
<h2 id="1-5-原理"><a href="#1-5-原理" class="headerlink" title="1.5 原理"></a>1.5 原理</h2><p>关联规则的挖掘目标是找出所有的频繁项集和根据频繁项集产生强关联规则.对于Apriori算法来说,其目标是找出所有的频繁项集,因此对于数据集合中的频繁数据集,我们需要自定义评估标准来找出频繁项集,常用的评估标准就是上述介绍的支持度.</p>
<p>Apriori算法是经典生成关联规则的频繁项集挖掘算法,其目标是找到最多的<strong>K项频繁集</strong>,那么什么是最多的K项频繁集呢?例如当我们找到符合支持度的频繁集AB和ABE,我们会选择3项频繁集ABE.下面我们介绍Apriori算法选择频繁K项集过程.</p>
<p><strong>如果某个项集是频繁项集，那么它所有的子集也是频繁的，即如果{0，1}是频繁，那么{0}，{1}也一定是频繁的。这个原理直观上没有什么用，但是反过来看就很有用了，也就是说如果一个项集是非平频繁的，那么它的所有超集也是非频繁的。</strong></p>
<p><img src="3.png" alt="计算方法"></p>
<p>Apriori算法采用迭代的方法，先搜索出候选1项集以及对应的支持度，剪枝去掉低于支持度的候选1项集，得到频繁1项集。然后对剩下的频繁1项集进行连接，得到候选2项集，筛选去掉低于支持度的候选2项集，得到频繁2项集。如此迭代下去，直到无法找到频繁k+1集为止，对应的频繁k项集的集合便是算法的输出结果。我们可以通过下面例子来看到具体迭代过程。</p>
<p><img src="5.png" alt="计算方法"></p>
<p>数据集包含4条记录{‘134’,‘235’,‘1235’,‘25’}，我们利用Apriori算法来寻找频繁k项集，最小支持度设置为50%。首先生成候选1项集，共包含五个数据{‘1’,‘2’,‘3’,‘4’,‘5’}，计算5个数据的支持度，然后对低于支持度的数据进行剪枝。其中数据{4}支持度为25%，低于最小支持度，进行剪枝处理，最终频繁1项集为{‘1’,‘2’,‘3’,‘5’}。根据频繁1项集连接得到候选2项集{‘12’,‘13’,‘15’,‘23’,‘25’,‘35’}，其中数据{‘12’,‘15’}低于最低支持度，进行剪枝处理，得到频繁2项集为{‘13’,‘23’,‘25’,‘35’}。如此迭代下去，最终能够得到频繁3项集{‘235’}，由于数据无法再进行连接，算法至此结束。</p>
<p><img src="3.png" alt="计算方法"></p>
<h1 id="二、频繁项集"><a href="#二、频繁项集" class="headerlink" title="二、频繁项集"></a>二、频繁项集</h1><p>主要步骤：</p>
<ul>
<li>生成所有单个物品的项集列表</li>
<li>扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉</li>
<li>对剩下的集合进行组合以生成包含两个元素的项集</li>
<li>接下来重新扫描交易记录，去掉不满足最小支持度的项集，重复进行直到所有项集都被去掉</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">实验要求：利用Apriori算法求出事务表中的频繁项集和关联规则。</span></span><br><span class="line"><span class="string">实验数据：10个购物篮事务构成的下列事务表，事务表由项目集I=&#123; I1，I2，I3，I4，I5，I6&#125;组成（项目集I中个项目对应的信息为：I1-牛奶，I2-啤酒，I3-尿布，I4-面包，I5-黄油，I6-饼干）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 其中，最小支持度设定为3，最小置信度设定为70%。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TID	商品</span></span><br><span class="line"><span class="string">T100	牛奶，啤酒，尿布</span></span><br><span class="line"><span class="string">T200	牛奶，面包，黄油</span></span><br><span class="line"><span class="string">T300	牛奶，尿布，饼干</span></span><br><span class="line"><span class="string">T400	面包，黄油，饼干</span></span><br><span class="line"><span class="string">T500	啤酒，尿布，饼干</span></span><br><span class="line"><span class="string">T600	牛奶，尿布，面包，黄油</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">T700	尿布，面包，黄油</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">T800	啤酒，尿布</span></span><br><span class="line"><span class="string">T900	牛奶，尿布，面包，黄油</span></span><br><span class="line"><span class="string">T1000	啤酒，饼干</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I1-牛奶，I2-啤酒，I3-尿布，I4-面包，I5-黄油，I6-饼干</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">## 频繁项集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        [<span class="string">'I1'</span>, <span class="string">'I2'</span>, <span class="string">'I3'</span>],</span><br><span class="line">        [<span class="string">'I1'</span>, <span class="string">'I4'</span>, <span class="string">'I5'</span>],</span><br><span class="line">        [<span class="string">'I1'</span>, <span class="string">'I3'</span>, <span class="string">'I6'</span>],</span><br><span class="line">        [<span class="string">'I4'</span>,<span class="string">'I5'</span>,<span class="string">'I6'</span>],</span><br><span class="line">        [<span class="string">'I2'</span>, <span class="string">'I3'</span>, <span class="string">'I6'</span>],</span><br><span class="line"></span><br><span class="line">        [<span class="string">'I1'</span>, <span class="string">'I3'</span>, <span class="string">'I4'</span>,<span class="string">'I5'</span>],</span><br><span class="line">        [<span class="string">'I3'</span>, <span class="string">'I4'</span>, <span class="string">'I5'</span>],</span><br><span class="line">        [<span class="string">'I2'</span>, <span class="string">'I3'</span> ],</span><br><span class="line">        [<span class="string">'I1'</span>, <span class="string">'I3'</span>, <span class="string">'I4'</span>,<span class="string">'I5'</span>],</span><br><span class="line">        [<span class="string">'I2'</span>, <span class="string">'I6'</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有元素转换为frozenset型字典，存放到列表中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createC1</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> [item] <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item])</span><br><span class="line">    C1.sort()</span><br><span class="line">    <span class="comment"># 使用frozenset是为了后面可以将这些值作为字典的键</span></span><br><span class="line">    <span class="keyword">return</span> list(map(frozenset, C1))  <span class="comment"># frozenset一种不可变的集合，set可变集合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤掉不符合支持度的集合</span></span><br><span class="line"><span class="comment"># 返回 频繁项集列表retList 所有元素的支持度字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanD</span><span class="params">(D, Ck, minSupport)</span>:</span></span><br><span class="line">    ssCnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):  <span class="comment"># 判断can是否是tid的《子集》 （这里使用子集的方式来判断两者的关系）</span></span><br><span class="line">                <span class="keyword">if</span> can <span class="keyword">not</span> <span class="keyword">in</span> ssCnt:  <span class="comment"># 统计该值在整个记录中满足子集的次数（以字典的形式记录，frozenset为键）</span></span><br><span class="line">                    ssCnt[can] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ssCnt[can] += <span class="number">1</span></span><br><span class="line">    numItems = float(len(D))</span><br><span class="line">    retList = []  <span class="comment"># 重新记录满足条件的数据值（即支持度大于阈值的数据）</span></span><br><span class="line">    supportData = &#123;&#125;  <span class="comment"># 每个数据值的支持度</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">        support = ssCnt[key] / numItems</span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>, key)</span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList, supportData  <span class="comment"># 排除不符合支持度元素后的元素 每个元素支持度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成所有可以组合的集合</span></span><br><span class="line"><span class="comment"># 频繁项集列表Lk 项集元素个数k  [frozenset(&#123;2, 3&#125;), frozenset(&#123;3, 5&#125;)] -&gt; [frozenset(&#123;2, 3, 5&#125;)]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span><span class="params">(Lk, k)</span>:</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = len(Lk)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenLk):  <span class="comment"># 两层循环比较Lk中的每个元素与其它元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, lenLk):</span><br><span class="line">            L1 = list(Lk[i])[:k - <span class="number">2</span>]  <span class="comment"># 将集合转为list后取值</span></span><br><span class="line">            L2 = list(Lk[j])[:k - <span class="number">2</span>]</span><br><span class="line">            L1.sort();</span><br><span class="line">            L2.sort()  <span class="comment"># 这里说明一下：该函数每次比较两个list的前k-2个元素，如果相同则求并集得到k个元素的集合</span></span><br><span class="line">            <span class="keyword">if</span> L1 == L2:</span><br><span class="line">                retList.append(Lk[i] | Lk[j])  <span class="comment"># 求并集</span></span><br><span class="line">    <span class="keyword">return</span> retList  <span class="comment"># 返回频繁项集列表Ck</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装所有步骤的函数</span></span><br><span class="line"><span class="comment"># 返回 所有满足大于阈值的组合 集合支持度列表</span></span><br><span class="line"><span class="comment"># minSupport 最小支持度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apriori</span><span class="params">(dataSet, minSupport=<span class="number">0.3</span>)</span>:</span></span><br><span class="line">    D = list(map(set, dataSet))  <span class="comment"># 转换列表记录为字典  [&#123;1, 3, 4&#125;, &#123;2, 3, 5&#125;, &#123;1, 2, 3, 5&#125;, &#123;2, 5&#125;]</span></span><br><span class="line">    C1 = createC1(</span><br><span class="line">        dataSet)  <span class="comment"># 将每个元素转会为frozenset字典    [frozenset(&#123;1&#125;), frozenset(&#123;2&#125;), frozenset(&#123;3&#125;), frozenset(&#123;4&#125;), frozenset(&#123;5&#125;)]</span></span><br><span class="line">    L1, supportData = scanD(D, C1, minSupport)  <span class="comment"># 过滤数据</span></span><br><span class="line">    L = [L1]</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (len(L[k - <span class="number">2</span>]) &gt; <span class="number">0</span>):  <span class="comment"># 若仍有满足支持度的集合则继续做关联分析</span></span><br><span class="line">        Ck = aprioriGen(L[k - <span class="number">2</span>], k)  <span class="comment"># Ck候选频繁项集</span></span><br><span class="line">        Lk, supK = scanD(D, Ck, minSupport)  <span class="comment"># Lk频繁项集</span></span><br><span class="line">        supportData.update(supK)  <span class="comment"># 更新字典（把新出现的集合:支持度加入到supportData中）</span></span><br><span class="line">        L.append(Lk)</span><br><span class="line">        k += <span class="number">1</span>  <span class="comment"># 每次新组合的元素都只增加了一个，所以k也+1（k表示元素个数）</span></span><br><span class="line">    <span class="keyword">return</span> L, supportData</span><br><span class="line"></span><br><span class="line">print(<span class="string">"=====频繁项集====="</span>)</span><br><span class="line">dataSet = loadDataSet()</span><br><span class="line">L, suppData = apriori(dataSet)</span><br><span class="line">print(L)</span><br><span class="line">print(suppData)</span><br></pre></td></tr></table></figure>

<p>返回频繁项集与支持度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[frozenset(&#123;<span class="string">'I6'</span>&#125;), frozenset(&#123;<span class="string">'I5'</span>&#125;), frozenset(&#123;<span class="string">'I4'</span>&#125;), frozenset(&#123;<span class="string">'I3'</span>&#125;), frozenset(&#123;<span class="string">'I2'</span>&#125;), frozenset(&#123;<span class="string">'I1'</span>&#125;)], [frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I3'</span>&#125;), frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I5'</span>&#125;), frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I1'</span>&#125;), frozenset(&#123;<span class="string">'I5'</span>, <span class="string">'I1'</span>&#125;), frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I5'</span>&#125;), frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I1'</span>&#125;), frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I2'</span>&#125;)], [frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I3'</span>, <span class="string">'I5'</span>&#125;), frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I5'</span>, <span class="string">'I1'</span>&#125;)], []]</span><br><span class="line">&#123;frozenset(&#123;<span class="string">'I1'</span>&#125;): <span class="number">0.5</span>, frozenset(&#123;<span class="string">'I2'</span>&#125;): <span class="number">0.4</span>, frozenset(&#123;<span class="string">'I3'</span>&#125;): <span class="number">0.7</span>, frozenset(&#123;<span class="string">'I4'</span>&#125;): <span class="number">0.5</span>, frozenset(&#123;<span class="string">'I5'</span>&#125;): <span class="number">0.5</span>, frozenset(&#123;<span class="string">'I6'</span>&#125;): <span class="number">0.4</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I2'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.4</span>, frozenset(&#123;<span class="string">'I2'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.1</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I5'</span>&#125;): <span class="number">0.5</span>, frozenset(&#123;<span class="string">'I5'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I6'</span>&#125;): <span class="number">0.2</span>, frozenset(&#123;<span class="string">'I6'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.1</span>, frozenset(&#123;<span class="string">'I6'</span>, <span class="string">'I5'</span>&#125;): <span class="number">0.1</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I6'</span>&#125;): <span class="number">0.1</span>, frozenset(&#123;<span class="string">'I6'</span>, <span class="string">'I2'</span>&#125;): <span class="number">0.2</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I5'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I3'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I2'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.1</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I5'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I3'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.2</span>, frozenset(&#123;<span class="string">'I4'</span>, <span class="string">'I3'</span>, <span class="string">'I5'</span>&#125;): <span class="number">0.3</span>, frozenset(&#123;<span class="string">'I3'</span>, <span class="string">'I5'</span>, <span class="string">'I1'</span>&#125;): <span class="number">0.2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码获取数据的频繁项集,下面通过其他函数来获得关联规则</p>
<h1 id="三、关联规则"><a href="#三、关联规则" class="headerlink" title="三、关联规则"></a>三、关联规则</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取关联规则的封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRules</span><span class="params">(L, supportData, minConf=<span class="number">0.7</span>)</span>:</span>  <span class="comment"># supportData 是一个字典</span></span><br><span class="line">    bigRuleList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L)):  <span class="comment"># 从为2个元素的集合开始</span></span><br><span class="line">        <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i]:</span><br><span class="line">            <span class="comment"># 只包含单个元素的集合列表</span></span><br><span class="line">            H1 = [frozenset([item]) <span class="keyword">for</span> item <span class="keyword">in</span> freqSet]  <span class="comment"># frozenset(&#123;2, 3&#125;) 转换为 [frozenset(&#123;2&#125;), frozenset(&#123;3&#125;)]</span></span><br><span class="line">            <span class="comment"># 如果集合元素大于2个，则需要处理才能获得规则</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>):</span><br><span class="line">                rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf)  <span class="comment"># 集合元素 集合拆分后的列表 。。。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                calcConf(freqSet, H1, supportData, bigRuleList, minConf)</span><br><span class="line">    <span class="keyword">return</span> bigRuleList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对规则进行评估 获得满足最小可信度的关联规则</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcConf</span><span class="params">(freqSet, H, supportData, brl, minConf=<span class="number">0.7</span>)</span>:</span></span><br><span class="line">    prunedH = []  <span class="comment"># 创建一个新的列表去返回</span></span><br><span class="line">    <span class="keyword">for</span> conseq <span class="keyword">in</span> H:</span><br><span class="line">        conf = supportData[freqSet] / supportData[freqSet - conseq]  <span class="comment"># 计算置信度</span></span><br><span class="line">        <span class="keyword">if</span> conf &gt;= minConf:</span><br><span class="line">            print(freqSet - conseq, <span class="string">'--&gt;'</span>, conseq, <span class="string">'conf:'</span>, conf)</span><br><span class="line">            brl.append((freqSet - conseq, conseq, conf))</span><br><span class="line">            prunedH.append(conseq)</span><br><span class="line">    <span class="keyword">return</span> prunedH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成候选规则集合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rulesFromConseq</span><span class="params">(freqSet, H, supportData, brl, minConf=<span class="number">0.7</span>)</span>:</span></span><br><span class="line">    m = len(H[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> (len(freqSet) &gt; (m + <span class="number">1</span>)):  <span class="comment"># 尝试进一步合并</span></span><br><span class="line">        Hmp1 = aprioriGen(H, m + <span class="number">1</span>)  <span class="comment"># 将单个集合元素两两合并</span></span><br><span class="line">        Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf)</span><br><span class="line">        <span class="keyword">if</span> (len(Hmp1) &gt; <span class="number">1</span>):  <span class="comment"># need at least two sets to merge</span></span><br><span class="line">            rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"=====关联规则====="</span>)</span><br><span class="line">dataSet = loadDataSet()</span><br><span class="line">L, suppData = apriori(dataSet, minSupport=<span class="number">0.5</span>)</span><br><span class="line">rules = generateRules(L, suppData, minConf=<span class="number">0.7</span>)</span><br><span class="line"><span class="comment"># rules = generateRules(L,suppData,minConf=0.5)</span></span><br><span class="line">print(rules)</span><br></pre></td></tr></table></figure>

<p>返回关联规则:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=====关联规则=====</span><br><span class="line">frozenset(&#123;'I5'&#125;) --&gt; frozenset(&#123;'I4'&#125;) conf: 1.0</span><br><span class="line">frozenset(&#123;'I4'&#125;) --&gt; frozenset(&#123;'I5'&#125;) conf: 1.0</span><br><span class="line">[(frozenset(&#123;<span class="string">'I5'</span>&#125;), frozenset(&#123;<span class="string">'I4'</span>&#125;), <span class="number">1.0</span>), (frozenset(&#123;<span class="string">'I4'</span>&#125;), frozenset(&#123;<span class="string">'I5'</span>&#125;), <span class="number">1.0</span>)]</span><br></pre></td></tr></table></figure>

<p>以上便是引用作者对这三个函数的详细描述，在函数中的具体代码，我也有相关的注释，慢慢来应该能够理解的。<br><img src="4.png" alt="计算方法"><br><img src="6.png" alt="计算方法"><br><img src="7.png" alt="计算方法"></p>
<p><a href="https://github.com/afrunk/DataMining/blob/master/Aprior%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/Apriori%E6%B1%82%E4%BA%8B%E5%8A%A1%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86%E5%92%8C%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99.py" target="_blank" rel="noopener">代码链接</a></p>
<h1 id="四、算法流程"><a href="#四、算法流程" class="headerlink" title="四、算法流程"></a>四、算法流程</h1><p>从Apriori算法原理中我们能够总结如下算法流程，其中输入数据为数据集合D和最小支持度α，输出数据为最大的频繁K项集。</p>
<ol>
<li>扫描数据集，得到所有出现过的数据，作为候补1项集</li>
<li>挖掘频繁K项集<br> a. 扫描计算候选K项集的支持度<br> b. 剪枝去掉候选K项集中支持度低于最小支持度α的数据及，得到频繁K项集，如果频繁K项集为空，则返回频繁K-1项集的集合作为算法结果，算法结束。如果得到的频繁K项集只有一项，则直接返回频繁K项集的集合作为算法结果，算法结束。<br> c. 基于频繁K项集，链接生成候选K+1项集</li>
<li>利用步骤2，迭代得到k=k+1项集结果。</li>
</ol>
<h1 id="五、优缺点"><a href="#五、优缺点" class="headerlink" title="五、优缺点"></a>五、优缺点</h1><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><ul>
<li>适合稀疏数据集</li>
<li>算法原理简单，易于实现</li>
<li>适合事务数据库的关联规则挖掘</li>
</ul>
<h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ul>
<li>可能产生庞大的候选集</li>
<li>算法需多次遍历数据集，算法效率低，耗时</li>
</ul>
<h1 id="六、算法推导实现流程"><a href="#六、算法推导实现流程" class="headerlink" title="六、算法推导实现流程"></a>六、算法推导实现流程</h1><h1 id="七、Director-Collaborator-Analysis"><a href="#七、Director-Collaborator-Analysis" class="headerlink" title="七、Director Collaborator Analysis"></a>七、Director Collaborator Analysis</h1>
      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://afrunk.github.io">Afrunk</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://afrunk.github.io/2019/11/05/Data-mining-Aporiori/">http://afrunk.github.io/2019/11/05/Data-mining-Aporiori/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        
        <nav class="post-nav"><a class="prev" href="/2019/11/07/Mathematical-basis/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Mathematical basis</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/10/18/贝叶斯建模/">
        <span class="next-text nav-default">贝叶斯建模</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:afrunk7@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/afrunk" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Afrunk</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
